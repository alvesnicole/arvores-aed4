#include <stdio.h>
#include <stdlib.h>

typedef enum { VERMELHO, PRETO} Cor;

typedef struct No{
  int chave;
  Cor cor;
  struct No *pai;
  struct No *esquerda;
  struct No* direita;
} No;

// Estrutura da Árvore Rubro-Negra
typedef struct ArvoreRubroNegra {
// Nó *raiz é o no que sempre aponta para o topo o valor da raiz
    No *raiz;
// Nó *NIL ele é um no tambem chamado de sentinela serve principalmente para simplificar o codigo
// o nó NIL substitui a verificação se o ponteiro é NULL e facilita o balanceamento
// sempre tera a cor PRETO e todo os nós folhas aponta para ele
    No *NIL;
} ArvoreRubroNegra;


/* ==-Função->================================ Criar Árvore ================================ */
// Função para fazer a criação da Arvore Rubro Negra
ArvoreRubroNegra* criar_arvore() {
// Realiza a alocação de memoria para o ponteiro T
    ArvoreRubroNegra* T = (ArvoreRubroNegra*)malloc(sizeof(ArvoreRubroNegra));
// Realiza a alocação de memoria para o ponteiro T->NIL
    T->NIL = (No*)malloc(sizeof(No));
// Inicializa na cor PRETO
    T->NIL->cor = PRETO;
// Inicializa com o valor 0
    T->NIL->chave = 0; 
// Inicializa com valor NULL
    T->NIL->esquerda = NULL;
// Inicializa com valor NULL
    T->NIL->direita = NULL;
// Inicializa com valor NULL
    T->NIL->pai = NULL;
// Como a raiz ainda não aponta para nada vai apontar para o T->NIL ao inves de NULL
    T->raiz = T->NIL;
    return T;
}


/* ==-Função->================================ Rotação Esquerda ================================ */
// Função para realizar o rebalanceamento da arvore quando pesa muito para a direita
void rotacao_esquerda(ArvoreRubroNegra *T, No *x) {
// y adota o filho x->direita
    No *y = x->direita;
// x->direita adota o filho y->esquerda 
    x->direita = y->esquerda;

    if (y->esquerda != T->NIL) {
// Garante que o no y->esquerda que foi adotado por x vai entender que x agora é seu pai
// por isso y->esquerda->pai = x está dizendo que x agora é pai de y->esquerda
        y->esquerda->pai = x;
    }
    
// A ligação que o pai de x tinha com x agora é refeita para y ou seja
// se x era a raiz da arvore agora y é a raiz
    y->pai = x->pai;
    if (x->pai == T->NIL) {
        T->raiz = y;
    } else if (x == x->pai->esquerda) {
        x->pai->esquerda = y;
    } else {
        x->pai->direita = y;
    }
    
// Agora x se torna o filho esquerdo de y
    y->esquerda = x;
    x->pai = y;
}


/* ==-Função->================================ Rotação Direita ================================ */
// Função para realizar o rebalanceamento da arvore quando pesa muito para a esquerda
void rotacao_direita(ArvoreRubroNegra *T, No *y) {
// x adota o filho y->esquerda
    No *x = y->esquerda;
// y->esquerda adota o filho x->direita
    y->esquerda = x->direita;

    if (x->direita != T->NIL) {
// Garante que o no x->direita que foi adotado por y vai entender que y agora é seu pai
// por isso x->direta->pai = y está dizendo que y agora é pai de x->direita
        x->direita->pai = y;
    }

// A ligação que o pai de y tinha com y agora é refeita para x ou seja
// se y era a raiz da arvore agora x é a raiz
    x->pai = y->pai;
    if (y->pai == T->NIL) {
        T->raiz = x;
    } else if (y == y->pai->direita) {
        y->pai->direita = x;
    } else {
        y->pai->esquerda = x;
    }
    
// Agora y se torna o filho direito de x
    x->direita = y;
    y->pai = x;
}


/* ==-Função->================================ Buscar ================================ */
// Função para buscar um valor na Arvore    Rubro   Negra
No* buscar(ArvoreRubroNegra *T, int chave) {
    No *atual = T->raiz;
// A função realiza a busca pelo valor desejado
// Se o valor for menor que a raiz ele vai para a esquerda
// Se for maior vai para a direita e retorna o ponteiro diferente de T->NIL
// Caso não encontre irá retorna T->NIL
    while (atual != T->NIL && chave != atual->chave) {
        if (chave < atual->chave) {
            atual = atual->esquerda;
        } else {
            atual = atual->direita;
        }
    }
    return atual;
}


/* ==-Função->================================ Inserir fixup ================================ */
// Função auxiliar para garantir que apos a inserção
// a Arvore Rubro Negra continuara balanceada
void inserir_fixup(ArvoreRubroNegra *T, No *z) {
// Como não pode ter VERMELHO com VERMELHO o while se basea no pai ser VERMELHO
    while (z->pai->cor == VERMELHO) {

// Esse if faz a seguinte pergunta o pai do meu nó z é o filho esquerdo do meu avó z
// Verficando se o caso VERMELHO com VERMELHO acontece
        if (z->pai == z->pai->pai->esquerda) {

// Logicamente se a esquerda é o pai a direita é o tio sendo nele que baseamos a troca de cor
            No *y = z->pai->pai->direita;
            
// Se o tio for vermelho fazemos a troca
            if (y->cor == VERMELHO) {
                
// z->pai->cor e y->cor onde y->cor é o tio mudam para PRETO
// e o nó avo z->pai->pai->cor vira VERMELHO
                z->pai->cor = PRETO;
                y->cor = PRETO;
                z->pai->pai->cor = VERMELHO;
// Essa parte é muito importante pois e se o bisavo for VERMELHO
// por isso z = z->pai->pai pois se o caso for verdadeiro o loop continua
                z = z->pai->pai;
            }

// E se o tio não for VERMELHO nesse caso executa o else
// Esse caso so ocorre quando o tio aponta para T->NIL ou seja o tio não tem valor
            else {
                
// Esse if verifica se o nó z é o filho direito
                if (z == z->pai->direita) {
                    
// Se for o ponteiro z sobe uma posição e realiza a rotação para a esquerda
                    z = z->pai;
                    rotacao_esquerda(T, z);
                }
// Essa trecho sempre será executado
// Ele muda o z->pai->cor para PRETO e o avo z->pai->pai->cor para VERMELHO
                z->pai->cor = PRETO;
                z->pai->pai->cor = VERMELHO;

// Realiza a rotação para a direita no avo para manter o balanceamento
                rotacao_direita(T, z->pai->pai);
            }
        }
        else {
            
// Nesse caso concluimos que o que o pai é o filho da direita
// Logo o tio tem que ser o filho a esquerda
// Seguindo a mesma logica da parte de cima somente com os lados invertidos
            No *y = z->pai->pai->esquerda;
            if (y->cor == VERMELHO) {
                z->pai->cor = PRETO;
                y->cor = PRETO;
                z->pai->pai->cor = VERMELHO;
                z = z->pai->pai;
            }
            else {
                if (z == z->pai->esquerda) {
                    z = z->pai;
                    rotacao_direita(T, z);
                }
                z->pai->cor = PRETO;
                z->pai->pai->cor = VERMELHO;
                rotacao_esquerda(T, z->pai->pai);
            }
        }
    }
    
// Força a raiz ser sempre PRETO
    T->raiz->cor = PRETO;
}


/* ==-Função->================================ Remover fixup ================================ */
// Função auxiliar para garantir que após a remoção
// a Arvore Rubro Negra continuara balanceada
void remover_fixup(ArvoreRubroNegra *T, No *x) {
    
// So acontece caso o valor removido seja PRETO
    while (x != T->raiz && x->cor == PRETO) {
        
// Verifica se o nó é do lado esquerda
        if (x == x->pai->esquerda) {

// Semelhante a inserção que olhamos para o nó tio aqui olharemos o nó irmão
// Caso o nó seja do lado esquerda o irmão obrigatoriamente tem que ser direita
            No *w = x->pai->direita; 
            
            if (w->cor == VERMELHO) {
                
// Se o irmão for vermelho muda a cor dele para PRETO
// A cor do pai para VERMELHO
                w->cor = PRETO;
                x->pai->cor = VERMELHO;
                
// Rotaciona o pai fazendo trocar de lugar com o filho w
                rotacao_esquerda(T, x->pai);
                
// Apos a rotação o ponteiro do irmão mudou isso garante que w aponte para o irmão x
                w = x->pai->direita;
            }
    
// Caso onde ambos os filhos de w são PRETO
            if (w->esquerda->cor == PRETO && w->direita->cor == PRETO) {
                
// w se torna VERMELHO, x se torna o novo pai e o cilho do while se repete novamente 
                w->cor = VERMELHO;
                x = x->pai;
            }
            

            else {
                
// Nesse caso sabemos que w tem um filho VERMELHO e confirmamos que ele está na esquerda
                if (w->direita->cor == PRETO) {
                    
// Mudamos a cor do filho para PRETO e o do pai para VERMELHO
                    w->esquerda->cor = PRETO;
                    w->cor = VERMELHO;
                    
// Rotaciona o filho para "Fora" para cair no proximo caso deixando a arvore como se estivesse em uma unica linha
                    rotacao_direita(T, w);
                    
// w aponta para o novo irmão x
                    w = x->pai->direita;
                }
                
// w herda a cor do pai, o pai recebe a cor PRETO e o filho direita fica PRETO
                w->cor = x->pai->cor;
                x->pai->cor = PRETO;
                w->direita->cor = PRETO;
                
// Rotação para garantir o rebalanceamento onde sub-árvore w sobe e o pai desce
                rotacao_esquerda(T, x->pai);
                
// Atribuimos x a T->raiz para finalizar o loop
                x = T->raiz;
            }
        }
    }
}


/* ==-Função->================================ Inserir ================================ */
//FUNÇÃO INSERÇÃO ABAIXO.
void inserir(ArvoreRubroNegra*T, int chave ){
  No* z = (No*)malloc(sizeof(No)); //No auxiliar + alocação de memoria + atriubição de valor ao No.
  z->chave = chave;

  //DOIS PONTEIROS DE BUSCA.
  No *y = T->NIL;
  No *x = T->raiz;

  //LOOP PARA ENCONTRAR FOLHA VAZIA
  while (x!= T->NIL){
    y = x; //o Y serve para o último lugar o último do  nó caso o X seja NIL.

//IF utilizado para mover o NO caso o valor for menor para esquerda ou maior para a direita.
    if(z->chave<x->chave){
      x = x->esquerda;
    }else{
      x = x->direita;
    }
  }
z-> pai = y;
if (y == T->NIL){
  T->raiz = z;
}// Usado caso o y esteja vazio a árvore também estará vazia, então o valor de y se tornará a raiz da árvore.
else if (z->chave < y->chave){
  y->esquerda = z;
}else {
  y->direita = z;
}
z->esquerda = T->NIL;
z->direita = T->NIL;
z->cor = VERMELHO;

inserir_fixup(T,z);
}


/* ==-Função->================================ Mínimo árvore ================================ */
// Função auxiliar para encontrar o nó com a chave mínima em uma sub-árvore
No* minimo_arvore(ArvoreRubroNegra *T, No *x) {
    while (x->esquerda != T->NIL) {
        x = x->esquerda;
    }
    return x;
}


/* ==-Função->================================ Transplantar ================================ */
// Função auxiliar para substituir uma sub-árvore por outra
void transplantar(ArvoreRubroNegra *T, No *u, No *v) {
    if (u->pai == T->NIL) {
        T->raiz = v;
    } else if (u == u->pai->esquerda) {
        u->pai->esquerda = v;
    } else {
        u->pai->direita = v;
    }
    v->pai = u->pai;
}





/* ==-Função->================================ Em ordem ================================ */
// Função para imprimir a árvore em ordem (chave e cor)
void em_ordem(ArvoreRubroNegra *T, No *no) {
    if (no != T->NIL) {
        em_ordem(T, no->esquerda);
        printf("%d(%s) ", no->chave, no->cor == VERMELHO ? "V" : "P");
        em_ordem(T, no->direita);
    }
}
/*FUNÇÃO REMOVER*/
void remover(ArvoreRubroNegra *T, int chave) {
    
// Utiliza a função de busca para encontrar o valor para remover
    No *z = buscar(T, chave);
    if (z == T->NIL) {
        printf("Nó com a chave %d não encontrado.\n", chave);
        return;
    }

// Cria um ponteiro auxiliar onde o nó que será verdadeiramente removido é y
    No *y = z;
    No *x;
    
// Guarda a cor original de y
    Cor cor_original_y = y->cor;

// Nesse caso z só tem filho direito
    if (z->esquerda == T->NIL) {
        x = z->direita;

// Substituimos z pelo seu filho direito
        transplantar(T, z, z->direita);
        
// Nesse caso z so tem o filho esquerdo
    }
    else if (z->direita == T->NIL) {
        x = z->esquerda;
        
// Substituimos z pelo seu filho esquerdo
        transplantar(T, z, z->esquerda);
    }
    
// Nesse caso z tem dois filhos
    else {
        
// Procura o sucessor de z que é o menor valor do nó direito
        y = minimo_arvore(T, z->direita);
        
// Guardamos a cor original do nó que será movido
        cor_original_y = y->cor;
        
// Aponta para o unico filho direito de y
        x = y->direita;
        
// Verifca se y é filho imediato de z
        if (y->pai == z) {
            
// Ajusta o ponteiro de x->pai para o caso de chamar a Função remover_fixup
            x->pai = y;
        }
        
// Trata o caso de y não ser o sucessor
        else {
            transplantar(T, y, y->direita);
            y->direita = z->direita;
            y->direita->pai = y;
        }
        
// y agora substitui z oficialmente
        transplantar(T, z, y);
        
// y adota a sub-árvore a esquerda de z
        y->esquerda = z->esquerda;
        y->esquerda->pai = y;
        
// y herda a cor de z
        y->cor = z->cor;
    }

// Como z foi removido liberamos sua memoria
    free(z);
    
// Caso a cor_original_y seja PRETO a Arvore Rubro Negra precisa ser corrigida
    if (cor_original_y == PRETO) {
        remover_fixup(T, x);
    }
}

/* FUNÇÃO REMOVER ACIMA*/


/* ==->########-================================ MAIN() ===================================== */
int main() {
    int opc = 0, valor;
    ArvoreRubroNegra *T = criar_arvore();
    No* resultado;

    do{
        printf("Escolha uma opcao abaixo.\n(0) Finalizar o programa.\n(1) Inserir um valor.\n(2) Remover um valor.\n");
        printf("(3) Procurar um valor.\n(4) Imprimir a Arvore Rubro Negra.\n");
        scanf("%d", &opc);
        
        switch(opc){
            
            case 0:
                printf("Programa Encerrado.\n");
                break;
                
            case 1:
                printf("Digite o valor que deseja inserir.\n");
                scanf("%d", &valor);
                inserir(T,valor);
                printf("Valor: %d inserido com sucesso.\n",valor);
            break;
            
            case 2:
                printf("Digite o valor que deseja remover.\n");
                scanf("%d",&valor);
                remover(T,valor);
                printf("Valor: %d removido com sucesso.\n", valor);
            break;
            
            case 3:
                printf("Digite o valor a ser buscado.\n");
                scanf("%d",&valor);
                resultado = buscar(T,valor);
                if (resultado != T->NIL) {
                    printf("Valor %d encontrada! Cor: %s\n", valor, resultado->cor == VERMELHO ? "Vermelho" : "Preto");
                }
                else {
                    printf("Valor %d não encontrada.\n", valor);
                }
            break;
            
            case 4:
                em_ordem(T, T->raiz);
                printf("\n");
            break;
            
            default:
                printf("Opcao não conhecida.\nTente Novamente.\n");
                break;
        }
        
    }while(opc != 0);
    
    return 0;
}
