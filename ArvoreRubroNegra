#include <stdio.h>
#include <stdlib.h>

typedef enum { VERMELHO, PRETO} Cor;

typedef struct No{
  int chave;
  Cor cor;
  struct No *pai;
  struct No *esquerda;
  struct No* direita;
} No;

// Função para realizar o rebalanceamento da arvore quando pesa muito para a direita
void rotacao_esquerda(ArvoreRubroNegra *T, No *x) {
// y adota o filho x->direita
    No *y = x->direita;
// x->direita adota o filho y->esquerda 
    x->direita = y->esquerda;

    if (y->esquerda != T->NIL) {
// Garante que o no y->esquerda que foi adotado por x vai entender que x agora é seu pai
// por isso y->esquerda->pai = x está dizendo que x agora é pai de y->esquerda
        y->esquerda->pai = x;
    }
    
// A ligação que o pai de x tinha com x agora é refeita para y ou seja
// se x era a raiz da arvore agora y é a raiz
    y->pai = x->pai;
    if (x->pai == T->NIL) {
        T->raiz = y;
    } else if (x == x->pai->esquerda) {
        x->pai->esquerda = y;
    } else {
        x->pai->direita = y;
    }
    
// Agora x se torna o filho esquerdo de y
    y->esquerda = x;
    x->pai = y;
}

// Função para realizar o rebalanceamento da arvore quando pesa muito para a esquerda
void rotacao_direita(ArvoreRubroNegra *T, No *y) {
// x adota o filho y->esquerda
    No *x = y->esquerda;
// y->esquerda adota o filho x->direita
    y->esquerda = x->direita;

    if (x->direita != T->NIL) {
// Garante que o no x->direita que foi adotado por y vai entender que y agora é seu pai
// por isso x->direta->pai = y está dizendo que y agora é pai de x->direita
        x->direita->pai = y;
    }

// A ligação que o pai de y tinha com y agora é refeita para x ou seja
// se y era a raiz da arvore agora x é a raiz
    x->pai = y->pai;
    if (y->pai == T->NIL) {
        T->raiz = x;
    } else if (y == y->pai->direita) {
        y->pai->direita = x;
    } else {
        y->pai->esquerda = x;
    }
    
// Agora y se torna o filho direito de x
    x->direita = y;
    y->pai = x;
}




// Função para buscar um valor na Arvore    Rubro   Negra
No* buscar(ArvoreRubroNegra *T, int chave) {
    No *atual = T->raiz;
// A função realiza a busca pelo valor desejado
// Se o valor for menor que a raiz ele vai para a esquerda
// Se for maior vai para a direita e retorna o ponteiro diferente de T->NIL
// Caso não encontre irá retorna T->NIL
    while (atual != T->NIL && chave != atual->chave) {
        if (chave < atual->chave) {
            atual = atual->esquerda;
        } else {
            atual = atual->direita;
        }
    }
    return atual;
}
//FUNÇÃO INSERÇÃO ABAIXO.
void inserir(ArvoreRubroNegra*T, int chave ){
  No z = (No)malloc(sizeof(No)); //No auxiliar + alocação de memoria + atriubição de valor ao No.
  z->chave = chave;

  //DOIS PONTEIROS DE BUSCA.
  No *y = T->NIL;
  No *x = T->raiz;

  //LOOP PARA ENCONTRAR FOLHA VAZIA
  while (x!= T->NIL){
    y = x; //o Y serve para o último lugar o último do  nó caso o X seja NIL.

//IF utilizado para mover o NO caso o valor for menor para esquerda ou maior para a direita.
    if(z->chave<x->chave){
      x = x->esquerda;
    }else{
      x = x->direita;
    }
  }
z-> pai = y;
if (y == T->NIL){
  T->raiz = z;
}// Usado caso o y esteja vazio a árvore também estará vazia, então o valor de y se tornará a raiz da árvore.
else if (z->chave < y->chave){
  y->esquerda = z;
}else {
  y->direita = z;
}
z->esquerda = T->NIL;
z->direita = T->NIL;
z->cor = VERMELHO;

inserir_fixup(T,z);
}
